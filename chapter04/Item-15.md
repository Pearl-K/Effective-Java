# Item 15. 클래스와 멤버의 접근 권한을 최소화하라
- 잘 설계된 컴포넌트의 기준: 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨긴다.
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽하게 숨겨, 구현과 API를 깔끔하게 분리한다.
- 오직 API를 통해서만 다른 컴포넌트와 소통하고, 서로의 내부 동작 방식은 전혀 모른다.
- 이는 "캡슐화" 라는 개념으로 OOP 특징 및 소프트웨어 설계 근간이 되는 원리이다.

## 정보 은닉(캡슐화)의 장점
1. 시스템 개발 속도 높임: 여러 컴포넌트의 병렬적 개발
2. 시스템 관리 비용 감소: 각 컴포넌트를 쪼개면, 더 빠른 파악과 디버깅이 가능하고 교체도 편리하다.
3. 정보 은닉 자체가 성능을 높여주는 것은 아니지만, 성능 최적화에 도움이 된다.
   - 최적화할 컴포넌트만 골라서 수정하고, 다른 컴포넌트에는 영향을 주지 않기 때문.
4. 소프트웨어 재사용성을 높인다.
   - 외부에 의존하지 않는 독자적인 컴포넌트는 낯선 환경에 적용해도 재사용 가능할 것이다.
5. 큰 시스템을 제작하는 난이도를 낮춘다.
   - 시스템 전체가 완성되지 않아도 개별 컴포넌트를 검증/테스트 할 수 있다.


## Java의 정보 은닉 장치
- 접근 제어 메커니즘을 통해 클래스, 인터페이스, 멤버의 접근성 (접근 허용 범위)를 명시한다.
- 각 요소의 접근성은, 요소가 선언된 위치와 접근 제한자(`public`, `protected`, `private`)로 정해진다.


## 접근제한자 사용의 기본 원칙
- 모든 클래스와 멤버의 접근성을 가능한 좁혀야 한다.
- 톱레벨 클래스와 인터페이스를 public으로 선언하면, 공개 API가 된다. 
- 따라서, 패키지 외부에서 쓸 일이 없다면 `package-private`으로 선언하여 해당 패키지 안에서만 이용할 수 있게 하자.

> 공개 API에서 내부 구현으로 되어 언제든 내부 수정을 할 수 있다. 
>
> 즉, 클라이언트에 아무런 피해나 변경 사항 없이 내부를 수정, 교체, 제거할 수 있게 된다.
> 
> 반면, `public` 이라면 API가 되므로 외부 사용이나 하위 호환을 위해 영원히 관리해야만 한다.


## 멤버 접근 제한자
- `private` : 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- `package-private` : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이며, 단, 인터페이스는 기본적으로 public 이 적용된다.
- `protected` : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- `public` : 모든 곳에서 접근할 수 있다.


클래스의 공개 API를 세심히 설계한 후, 그 외 모든 멤버는 접근 범위에 따라 `private` 이나 `package-private` 으로 만들 수 있다.


private와 package-private 멤버는 모두 해당 클래스의 구현에 해당하여, 공개 API에 영향을 주지 않으나, Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있다. (추후 Item 86, 87 참고)

> `public` 클래스에서 멤버 접근 수준을 `protected`로 사용하면, 그 멤버에 접근할 수 있는 대상 범위가 엄청나게 넓어진다. 
> 
> `public` 클래스의 `protected` 멤버는 공개 API로 영원히 지원되어야 하며, 내부 동작 방식을 API 문서에 적어 사용자에게 공개해야할 수 있다. 따라서, `protected` 멤버는 적을 수록 좋다.


## 주의해야 할 점
### 1. LSP를 지키기 위해 필요한 원칙
- 상위 클래스의 메서드를 재정의 할 때, 접근 수준을 상위 클래스보다 좁게 설정할 수 없다.
- 이 제약 조건은, 상위 클래스의 인스턴스를 하위 클래스의 인스턴스로 대체해 사용해도 동작해야한다는 LSP를 지키기 위해 필요하다.
- 이 규칙을 어기면 하위 클래스 컴파일에 오류가 난다.
- 이 때는, 클래스를 구현할 때 인터페이스가 정의한 모든 메서드를 `public`으로 선언해야 한다.


### 2. 단지 코드 테스트 목적으로 접근 범위를 넓히려고 하지 마라
- 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API로 만들어서는 안된다.
- 테스트 코드를 테스트 대상과 같은 패키지에 두어 `package-private` 요소에 접근할 수 있게 만드는 방식을 사용해야 한다.


### 3. `public` 클래스의 인스턴스 필드는 되도록 `public` 이 아니어야 한다.
- 필드가 가변 객체를 참조하거나, `final`이 아닌 인스턴스 필드를 `public` 으로 선언하면 그 필드에 담을 값을 제한할 힘을 잃게 된다.
- 해당 필드와 관련된 불변식을 보장할 수 없다.
- `public` 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.


### 4. 정적 필드에서의 문제
- 정적 필드에서도 위와 같은 `public` 접근제어자 문제를 지켜야 한다.
- 단 하나의 예외가 있다면, `public static final` 필드로, 클래스의 상수로서 반드시 기본 타입 값이나 불변 객체를 참조해야 한다.
- 특히, 길이가 0이 아닌 배열은 모두 변경 가능하므로, 클래스에서 `public static final` 배열 필드를 두거나, 이 필드를 반환하는 접근자 메서드를 두어서도 안된다.


만약, 배열이 필요한 경우 다음과 같은 두 가지 해결법을 쓸 수 있다.
1. `private` 배열로 만들고, `public` 불변 리스트를 추가하는 것
    ```java
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
   ```
2. `private` 배열로 만들고, 이 배열의 복사본을 반환하는 `public` 메서드를 만드는 것 (방어적 복사)
    ```java
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final Thing[] values(){
        return PRIVATE_VALUES.clone();
    }
   ```

## Java9+ 모듈 시스템
- 모듈 시스템 개념 도입으로, 두 가지 암묵적 접근 수준이 추가되었다.
- 패키지가 클래스들의 묶음이라면, 모듈은 패키지들의 묶음이다.
- 모듈은 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서 자유롭게 공유할 수 있다. 
- 모듈은 자신에 속하는 패키지 중 공개(export) 할 것들을 `module-info.java`에 선언하며, 해당 패키지를 공개하지 않으면 `protected`, `public` 멤버도 모듈 외부에서 접근할 수 없다.
- 주의해야할 점으로, 모듈의 `jar` 파일을 자신의 모듈 경로가 아닌 애플리케이션 클래스 패스에 둔다면 그 모듈 안의 모든 패키지는 마치 모듈이 없는 것처럼 동작한다. 
  - 즉, 모듈이 공개(export)했는지 여부와 상관 없이 `public` 클래스가 선언한 모든 `public`, `protected` 멤버를 모듈 밖에서도 접근할 수 있다.

    

> Java 9의 모듈 시스템은 패키지 간 접근을 엄격히 제한하고, 명시적인 의존성 선언을 통해 보안성과 유지보수성을 높일 수 있다.
> 
> 그러나 라이브러리 호환성과 마이그레이션 비용 문제로 인해 실제 Java 애플리케이션에서는 잘 사용되지 않는다. (꼭 필요한 경우가 아니라면 굳이 사용할 필요 없다.)


## Summary
- 프로그램 요소의 접근성은 가능한 최소로 만들자.
- 꼭 필요한 것만 골라서 최소한의 public API로 설계하는 것이 좋다.
- 그 외에는 클래스, 인터페이스, 멤버들이 의도치 않게 API로 공개되는 일이 없도록 만들어야 한다.
- `public` 클래스는 `public static final` 필드 외에 어떠한 `public` 필드도 가져서는 안된다.
- `public static final`을 사용할 경우, 이 필드가 찾모하는 객체가 불변 객체인지 확인해야 한다.