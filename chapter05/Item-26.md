# Item 26. 로 타입은 사용하지 말라
클래스와 인터페이스 선언에 타입 매개변수가 쓰이면 이를 제네릭 클래스 or 제네릭 인터페이스라고 한다.
제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라고 한다.


---
## 제네릭 관련 용어 정리
- 한글로 번역했을 때 의미가 헷갈릴 수도 있어 각 용어가 어떤 것을 의미하는지 정확히 아는 것이 중요하다.


| 한글 용어 | 영문 용어 | 예시 |
|----------|----------|----------|
|  로 타입    |  raw type        |  `List`    |
|  제네릭 타입     |  generic type      |  `List<E>`    |
|  매개변수화 타입     |  parameterized type   |  `List<String>`   |
|  정규 타입 매개변수     | formal type parameter   |  `E`     |
|  실제 타입 매개변수     | actual type parameter   | `String`     |
|  한정적 타입 매개변수      |  bounded type parameter        | `<E extends Number>`    |
|  비한정적 와일드카드 타입     | unbounded wildcard type  |  `List<?>`    |
|  한정적 와일드카드 타입     |  bounded wildcard type     |  `List<? extends Number>`  |
|  재귀적 타입 한정    | recursive type bound  | `<T extends Comparable<T>>`   |
|  제네릭 메서드      |  generic method       |  `static <E> List <E> asList(E[] a)`   |
|  타입 토큰     | type token    |  `String.class`        |


---
## Raw Type 위험성
- 제네릭 타입을 하나 정의하면 그에 딸린 raw type 도 함께 정의된다.
- 이는 제네릭이 존재하지 않던, 이전 버전과의 호환을 위해 만들어진 것이지만 런타임 오류 가능성으로 인해 사용을 피해야한다.
- 제네릭을 활용하여 선언 시에 타입을 제한하는 것이 좋다. (컴파일 타임 체크 가능)
- 이를 무시하고 raw type을 쓰는 것은 제네릭이 주는 이점 (안전성과 표현력)을 잃게 된다.


---
## 매개변수화 타입을 사용해도 되는 이유
- 변성 개념
    - 공변(covariant): 하위 타입 컨테이너를 상위 타입 컨테이너 자리에 그대로 넣을 수 있는 성질
- Java의 제네릭은 공변성을 지원하지 않는다.
    - `List<T>`, `List<E>` 이렇게 매개변수로 들어간 T와 E 사이의 상속관계가 있어도 서로 다르면 받을 수 없다.
    - 이를 통해 제네릭의 타입 안전성을 지킨다.
    - 특정 클래스를 상속한 경우를 모두 받고 싶다면 `List<? extends Number>` 이런식으로 한정적 와일드카드를 사용할 수 있다.
- [Kotlin은 변성 개념이 달라서 Java와의 차이를 공부해보는 것도 좋다.](https://jeongmin.github.io/2024/04/13/kotlin/variance%20in%20kotlin%20and%20java/)



---
## 원소의 타입을 몰라도 되는 코드를 짜고 싶을 때? (비한정적 와일드카드 타입 사용)
- Raw Type은 타입을 명시하지 않아도 되니, 타입을 모를 때 사용하려고 시도할 수도 있다. 하지만 이는 타입 안전하지 않은 선택이다.
- 타입을 모르는 상태로 아무 원소나 넣어서 타입 안전성을 훼손하기 쉽다.
- 이럴 때는 타입을 알 수 없다는 것을 비한정적 와일드카드를 명시해서 알려줄 수 있다.
- `<?>`는 “알 수 없는(Some capture-of ?) 타입”으로 취급되어, 컴파일러가 쓰기를 원천적으로 막는다.
    - null 외에는 어떤 원소도 넣을 수 없다.
    - 타입을 모르니, 함부로 변경하지 않고 읽기 전용으로 쓰겠다는 의미가 내포되어있다.
    - 비한정적 와일드카드를 사용하면, 잘못된 변경이 있을 때 (ex. 아무 원소나 add하는 코드) 컴파일 타임 오류로 잡아낸다.


---
## 로 타입을 사용해야하는 예외 상황
> 단, 다음 두 경우는 **JVM 레벨에서도 제네릭 정보를 갖고 있지 않기 때문에** 로 타입을 쓰는 것이 유일한 방법이다.


### 1. class 리터럴에서
- **Why?**  
  - 자바의 타입 소거 때문에 `List<String>.class` 같은 문법은 존재하지 않는다.  
  - JVM이 실제로 보관하는 메타데이터도 `java.util.List` 하나뿐이기 때문이다.



### 2. `instanceof` 연산자에서
- **Why?** 
    - `instanceof List<String>` 는 문법적으로 금지
    -  타입 소거로 런타임에 구체 타입 파라미터를 알 수 없다.
    - 따라서, 로 타입으로 `instanceof` 연산을 수행하고, 바로 아래에 검사 형변환(checked cast)를 해줘야한다.


```java
if (o instanceof Set) {
    Set<?> s = (Set<?>) o;
    ...
}
```


---
## Summary
- 로 타입은 런타임에 예외가 일어날 수 있으니 쓰지 않는게 좋다.
- 로 타입은 제네릭이 도입되기 이전 버전의 코드와 호환성을 위한 용도이다.
- 매개변수화 타입이나 와일드카드 타입 모두 안전하기 때문에 로 타입 대신 사용하자.
    - 단, Java 제네릭 타입 시스템의 "변성" 개념을 이해한다면 더 잘 이해할 수 있다.