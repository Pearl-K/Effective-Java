# Item 28. 배열보다는 리스트를 사용하라
- 배열과 제네릭 타입에 중요한 차이 두 가지가 있다. (공변성 관련)


1. 배열은 공변이다.
2. 제네릭은 불공변이다.

> 공변(covariant)이란?
> 
> 함께 변한다는 의미로, `Sub` 가 `Super` 의 하위 타입이면, 배열 `Sub[]`도 `Super[]` 배열의 하위 타입이 된다.
> 
> 제네릭은 불공변이므로, `List<Sub>`가 `List<Super>`의 하위타입이 되지 않는다. (서로 별개)
>

그러나 배열이 공변성이 있기 때문에 생기는 문제가 있다.

---
## 1. 예상치 못한 런타임 오류 가능성이 생긴다.
- ex. 상위 타입으로 Array를 선언하고, 특정한 하위 타입으로 구체화한 배열이 있을 때, 상위 타입을 상속한 다른 하위 타입으로 값을 변경하려는 코드를 짤 수 있다.
- 이런 코드가 컴파일 타임에 잡히지 않아서 위험해진다.


```java
Object[] objectArray = new Long[1];
objectArray[0] = "sample string"; // ArrayStoreException 발생
```


그러나 제네릭을 사용하면 컴파일 타임에 이런 오류가 잡히기 때문에 더 안전하다.


```java
List<Object> o = new ArrayList<Long>();
o.add("sample string");
```


- `List<T>`는 무공변이라 `ArrayList<Long>`을 `List<Object>` 변수에 대입할 수 없다.
- 즉, 컴파일러가 첫번째 줄에서 멈추기 때문에 다음 줄은 애초에 컴파일 단계까지 가지 않는다.


---
## 2. 배열의 실체화
- 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
- 그러나, 제네릭은 타입 정보가 런타임에 소거된다.
  - 원소 타입을 컴파일 타임에만 검사하며, 런타임에는 모른다는 의미이다.
  - 타입 소거는 제네릭이 지원되기 전에 레거시 코드(이전 자바 버전)와 제네릭을 함께 사용할 수 있게 해주는 메커니즘이다.
  - 정리하면, 타입 정보를 인지하고 있는 배열과, 타입 정보가 소거된 제네릭이 서로 달라 잘 어우러지지 못한다.


---
## 제네릭 배열을 만들지 못하는 이유

