# Item 71. 필요 없는 검사 예외 사용은 피하라

검사 예외를 제대로 활용하면 API와 프로그램의 질을 높일 수 있다. 그러나 너무 과도한 사용은 API의 질을 낮출 수 있어 조심해야 한다.


그 이유는, 예외를 잡는 책임이 호출하는 측에 주어지기 때문이다. 예를 들어, `try-catch` 문을 사용해서 그 예외를 붙잡아 처리하거나, 더 바깥으로 문제를 전파해야 한다. 


특히, 단 하나의 검사 예외만 던지는 경우에는 그 하나의 예외로 인해 API 사용자가 try 블록을 추가하는 비용이 발생한다.


또한, Stream 안에서는 검사 예외를 던지는 메서드를 직접 사용할 수 없기 때문에 부담이 커진다. (특히, Stream을 적극적으로 사용하는 문화)


따라서, 다음과 같이 두 가지를 생각한 후 도입하면 좋다.

1. API를 제대로 사용해도 발생할 수 있는 예외일 때

2. 프로그래머가 의미 있는 조치를 취할 수 있는 경우
    - 복구 시도 등



위 두 가지 중 어디에도 해당하지 않을 때는 비검사 예외를 사용하는 것이 좋다.


## 검사 예외를 회피하는 방법
- 적절한 결과 타입을 담은 Optional 을 반환하는 것이다.
- 검사 예외를 던지는 대신, 단순히 빈 Optional 을 반환하면 된다.
- 그러나, 예외 발생 이유(부가 정보)를 알려줄 수 없다는 단점이 있다.
- 또 다른 방법으로, 검사 예외를 던지는 메서드를 2개로 쪼개서 비검사 예외로 바꾸는 것이다.


```java
// Code 1. 검사 예외를 던지는 메서드
try {
    obj.action(args);
} catch (TheCheckedException e) {
    // ... 예외 상황 대처
}

// Code 2. 상태 검사 메서드를 통해 상태 검사를 한 후, 비검사 예외를 던지는 메서드
if (obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // ... 예외 상황 대처
}
```


이런 리팩토링 코드는 보기에 깔끔하거나 아름답지는 않지만, 더 유연한 것은 사실이다. 그러나 상태 검사 메서드의 단점(Item 69)이 있으니 이를 기억하고 사용해야 한다.


즉, 외부 동기화 없이 여러 스레드가 동시 접근 가능하거나 외부 요인에 의해 상태가 바뀌는 경우 위 리팩토링 방식은 적절하지 않다는 의미이다. 또한, `actionPermitted` 와 `action()` 메서드의 작업 일부가 중복되어 중복 수행된다면 성능 손해이기도 하다.


---
## Summary
- 꼭 필요한 곳에만 사용한다면, 검사 예외는 프로그램의 안전성을 높여준다.
- 그러나 과도한 사용은 계속 검사 예외를 체크하는 책임이 있어 사용하기 어려운 API를 만든다.
- API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지도록 하자.
- 복구가 가능하고 호출자가 handling 가능한 상황이면 검사 예외를 던질수도 있으나, 먼저 `Optional` 반환이 가능한지(검사 예외를 회피할 수 있는지) 고민해보자.
    - `Optional` 만으로 상황 해결이 부족하고, 추가 정보가 제공되어야 하는 경우 검사 예외를 던지자.