# Item 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
CPU 스케줄링 정책은 OS마다 달라질 수 있다. 따라서, 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램은 좋지 못하다.


OS에 대한 의존성이 높아 다른 플랫폼에 이식하기 어렵다. (이식성 나쁨)


### 이식성이 낮아지는 이유
스레드 스케줄러는 우선순위, CPU 점유 시간, I/O 상태 등 다양한 요소에 따라 동작을 결정한다. 따라서 어떤 OS에서는 잘 동작하던 동시성 로직이 다른 환경에서는 오동작하거나 성능이 급격히 떨어질 수 있다. 이식성과 안정성을 모두 해치는 코드다.


### 실행 가능한 스레드 수를 제어하라
견고하고 빠르고 이식성 높은 프로그램을 위해서는, 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다. 


그래야 스레드 스케줄러가 고민할 거리가 줄어든다. (사실 이 수를 조절하는 것은 CPU Bound 작업인지, I/O Bound 작업인지에 따라서도 권장 정도가 달라지기 때문에 주의!)


> 현업에서는 서버 당 cpu 사용률도 매우 민감하게 본다. 사용률 기준은 회사마다 다르지만, 기본적으로 서버의 cpu 스펙을 기반으로 무리하지 않을 만큼의 수치를 유지해야 한다.


또한, 실행 가능한 스레드 수와 전체 스레드 수를 구분해야 한다. 전체 스레드 수는 훨씬 많을 수 있고, 대기 중인 스레드는 실행 가능하지 않음을 기억하자.


---
## 스레드의 바쁜 대기(busy-wating) 상태를 피하라
Busy-waiting은 스레드가 유휴 상태에서도 계속 CPU를 소비하며 루프를 도는 방식이다. 


예를 들어 아래와 같은 코드를 보자.


```java
while (!condition) {
    // do nothing
}
```


이런 코드는 CPU를 낭비하면서도 아무 일도 하지 않는다. CPU 자원을 과도하게 점유하고 다른 스레드에게 기회를 주지 못해 전체 시스템 성능을 망친다.


---
## `Thread.yield`는 힌트로만 사용하자 (문제의 해법으로 남용 금지)
`Thread.yield()`는 현재 실행 중인 스레드가 자발적으로 CPU 점유를 포기하고 다른 스레드에게 실행 기회를 양보하도록 JVM에 요청하는 메서드이다.


하지만 중요한 것은, 이 동작이 실질적으로 보장되지 않는다는 것이다. 스레드 스케줄러가 이를 무시할 수도 있다. 


즉, yield()는 힌트이지 강제 사항이 아니므로 신뢰할 수 있는 동작 흐름 제어 방법이 아니고, 이를 무리한 서버 상태에서 해법처럼 적용하는 것도 안된다.



---
## 스레드 우선순위에 기대지 말자
스레드 몇 개의 우선순위를 조율해서 애플리케이션의 반응 속도를 높일 수는 있지만, 이식성이 매우 떨어지는 행동이다.


심각한 응답 불가 문제나 지연 문제를 스레드 우선순위로 해결하려는 시도는 합리적이지 않고, 근본 원인을 잡는 것이 아니라 편법에 해당한다. 근본 원인을 찾아서 수정하도록 하자.


---
## Summary
- 프로그램의 동작을 스레드 스케줄러에 기대면 안된다.
- 프로그램의 견고성과 이식성을 모두 해치는 행위이다.
- 같은 이유로, `Thread.yield` 와 스레드 우선순위에 의존해서도 안된다.
    - 이 기능은 스레드 스케줄러에 제공하는 힌트 용도로만 사용하자.